---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by xindong.
--- DateTime: 2021/2/4 22:36
---

--[[

local ed = ac.event_deque()
coroutine.wrap(function()
    local elem = ed.co_pop()  -- block
    run(elem)
end)()

]]--

local create_queue = require 'base.deque'.create_queue
local create_deque = require 'base.deque'.create_deque

local co_wrap = require 'base.co'.wrap

---@class event_deque
---@field push_front fun(self: event_deque, elem: any)
---@field pop_front fun(self: event_deque, timeout: number|nil, callback: fun(ret: any, err: string|nil)): any
---@field push_back fun(self: event_deque, elem: any)
---@field pop_back fun(self: event_deque, timeout: number|nil, callback: fun(ret: any, err: string|nil)): any
---@field co_pop_back fun(self: event_deque, timeout: number|nil): any, string|nil
---@field co_pop_front fun(self: event_deque, timeout: number|nil): any, string|nil
---@field close fun(self: event_deque, clean): nil
---@field closed fun(self: event_deque): boolean
---@field push fun(self: event_deque, elem: any)  alias push_back
---@field pop fun(self: event_deque, timeout: number|nil, callback: fun(ret: any, err: string|nil)): any  alias pop_back
---@field co_pop fun(self: event_deque, timeout: number|nil): any, string|nil   alias co_pop_back
local event_deque = {
    push_front = function(self, elem)
        while #self._callback_queue > 0 do
            local f = self._callback_queue:pop()
            if f then
                f(elem, nil)
                return
            end
        end

        self._elem_deque:push_front(elem)
    end,

    push_back = function(self, elem)
        while #self._callback_queue > 0 do
            local f = self._callback_queue:pop()
            if f then
                f(elem, nil)
                return
            end
        end

        self._elem_deque:push_back(elem)
    end,

    _pop_front = function(self, timeout, callback)
        if #self._elem_deque > 0 then
            local elem, err = self._elem_deque:pop_front()
            if callback then
                callback(elem, err)
            end
            return elem, err
        end

        if self:closed() then
            if callback then
                callback(nil, 'closed')
            end
            return nil, 'closed'
        end

        if callback then
            self:_push_callback(timeout, callback)
        end
        return nil, 'empty'
    end,

    _pop_back = function(self, timeout, callback)
        if #self._elem_deque > 0 then
            local elem, err = self._elem_deque:pop_back()

            if callback then
                callback(elem, err)
            end
            return elem, err
        end

        if self:closed() then
            if callback then
                callback(nil, 'closed')
            end
            return nil, 'closed'
        end

        if callback then
            self:_push_callback(timeout, callback)
        end
        return nil, 'empty'
    end,

    co_pop_back = function(self, timeout)
        local new_f = co_wrap(self._pop_back)
        return new_f(self, timeout)
    end,

    co_pop_front = function(self, timeout)
        local new_f = co_wrap(self._pop_front)
        return new_f(self, timeout)
    end,

    close = function(self, clean)
        self._elem_deque:close(clean)
        self._callback_queue:close(function(callback)
            callback(nil, 'closed')
        end)
    end,

    closed = function(self)
        return self._elem_deque:closed()
    end,

    __len = function(self)
        return #self._elem_deque
    end,

    _push_callback = function(self, timeout, callback)
        local called = false
        local cb = function(...)
            if called then
                return
            end
            called = true
            callback(...)
        end

        self._callback_queue:push(cb)
        if timeout then
            local back_index = self._callback_queue._back - 1  -- HACK the queue
            base.wait(timeout, function()
                self._callback_queue[back_index] = nil
                cb(nil, 'timeout')
            end)
        end
    end,
}

event_deque.__index = event_deque
event_deque.pop_front = event_deque._pop_front
event_deque.pop_back = event_deque._pop_back
event_deque.push = event_deque.push_back
event_deque.pop = event_deque._pop_front
event_deque.co_pop = event_deque.co_pop_front

---@return event_deque
local function create_event_deque()
    return setmetatable({
        _elem_deque = create_deque(),
        _callback_queue = create_queue(),
    }, event_deque)
end

---@class event_queue
---@field push fun(self: event_queue, elem: any)
---@field pop fun(self: event_queue, timeout: number|nil, callback: fun(ret: any, err: string|nil)): any
---@field co_pop fun(self: event_queue, timeout: number|nil): any, string|nil
---@field __len fun(self: event_queue): number
---@field close fun(self: event_queue, clean): nil
---@field closed fun(self: event_queue): boolean
local event_queue = {}
for k, v in pairs(event_deque) do
    event_queue[k] = v
end
event_queue.push_front = nil
event_queue.push_back = nil
event_queue.pop_front = nil
event_queue.pop_back = nil
event_queue.co_pop_front = nil
event_queue.co_pop_back = nil

event_queue.__index = event_queue

---@return event_queue
local function create_event_queue()
    return setmetatable({
        _elem_deque = create_deque(),
        _callback_queue = create_queue(),
    }, event_queue)
end

base.event_queue = create_event_queue
base.event_deque = create_event_deque

return {
    create_event_deque = create_event_deque,
    create_event_queue = create_event_queue,
}